/*  1196. Экзамен по истории
 *
 *    Ограничение времени: 1.5 секунды
 *    Ограничение памяти: 64 МБ
 *
 *  Будем справедливы: сессия ставит задачи не только студентам, но и
 *  преподавателям. Любой преподаватель обучает немалое количество студентов,
 *  а ведь каждого надо еще и проверить. Поэтому один из преподавателей решил
 *  принимать экзамен по истории по такой упрощённой процедуре: студент
 *  записывает все известные ему «исторические» даты (достаточно, чтобы он
 *  написал только года, но, конечно, мог объяснить, чем замечательна та или
 *  иная дата). Преподаватель же держит перед глазами список дат, которые
 *  студент должен знать. Для оценки знаний студента преподаватель подсчитывает
 *  количество чисел в списке студента, которые также есть в списке
 *  преподавателя. В зависимости от полученного числа и выставляется итоговая
 *  оценка.
 *
 *  Вы должны оказать посильную помощь в автоматизации этого процесса,
 *  разработав программу для подсчёта количества совпадений в списках студента
 *  и преподавателя.
 *
 *  Исходные данные
 *  В первой строке содержится число N — количество записей в списке
 *  преподавателя. 1 ≤ N ≤ 15000. Затем идет N строк, содержащих список
 *  преподавателя, по одной дате в строке. Записаны только года. Каждый год —
 *  целое число в пределах от 1 до 109. Даты в этом списке отсортированы по
 *  неубыванию. В следующей после списка строке содержится число M — количество
 *  записей в списке студента, 1 ≤ M ≤ 106. Затем также M строк с датами
 *  (записаны только года, каждый год — целое число в пределах от 1 до 109).
 *  Этот список не отсортирован. В списке как студента, так и преподавателя
 *  даты могут повторяться.
 *
 *  Результат
 *  Вы должны вывести одно число — количество чисел во втором списке, которые
 *  также содержатся в первом.
 *
 *  Примеры
 *    исходные данные         |   результат
 *  --------------------------+-----------------------------
 *    2                       |   2
 *    1054                    |
 *    1492                    |
 *    4                       |
 *    1492                    |
 *    65536                   |
 *    1492                    |
 *    100                     |
 *
 */

#include <iostream>
#include <string>
#include <map>
#include <vector>
#include <algorithm>

int main() {
  std::size_t n;
  std::cin >> n;
  std::vector<unsigned> first;
  first.reserve(n);

  for (std::size_t i = 0; i != n; ++i) {
    unsigned tmp;
    std::cin >> tmp;
    first.push_back(tmp);
  }

  std::size_t m;
  std::cin >> m;
  std::vector<unsigned> second;
  second.reserve(m);

  for (std::size_t i = 0; i != m; ++i) {
    unsigned tmp;
    std::cin >> tmp;
    second.push_back(tmp);
  }

  std::sort(first.begin(), first.end());
  std::sort(second.begin(), second.end());

  std::size_t eq_counter = 0;
  auto first_it = first.begin();
  auto second_it = second.begin();

  // find number of eq elems in both sorted vectors
  while (first_it != first.end() && second_it != second.end()) {
    if (*first_it == *second_it) {
      // only number of elems in second, that alse exist in third
      while (second_it != second.end() && *first_it == *second_it) {
        ++eq_counter;
        ++second_it;
      }
    }
    else if (*first_it < *second_it) {
      ++first_it;
    }
    else {
      ++second_it;
    }
  }

  std::cout << eq_counter;
}
